<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="shortcut icon" type="image/x-icon" href="/resources/images/favicon.png" />
    <!-- CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css" integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js" integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og==" crossorigin=""></script>
    <script src="//d3js.org/d3.v4.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/1.3.0/chroma.min.js"></script>
    <!-- Plugin -->
    <script src="resources/leaflet.canvaslayer.field.js"></script>
    <!-- Font -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">

    <style>
            html,
            body,
            #map {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background-color: #000;
                font-family: Inter, Arial, Helvetica, sans-serif;
            }

            #mapTitle {
                padding: 16px;
                z-index: 999;
                position: absolute;
                top: -10px;
                left: 10px;
                background-color: #2a2a2a !important;
                border-color: #2a2a2a !important;
                color: #fff !important;
            }

            /* Zoom Control Styling */

            .leaflet-bar,
            .leaflet-touch .leaflet-bar {
                border: none;
                box-shadow: none;
            }

            .leaflet-bar a:first-child,
            .leaflet-touch .leaflet-bar a:first-child {
                border-top-left-radius: 0;
                border-top-right-radius: 0;
                background-clip: padding-box;
                background-color: #2a2a2a;
                border-color: #2a2a2a;
                border-style: solid;
                border-width: 5px;
                color: #fff;
            }

            .leaflet-bar a:last-child,
            .leaflet-touch .leaflet-bar a:last-child {
                border-bottom-left-radius: 0;
                border-bottom-right-radius: 0;
                background-clip: padding-box;
                background-color: #2a2a2a;
                border-color: #2a2a2a;
                border-style: solid;
                border-width: 5px;
                color: #fff;
                margin-top: 16px;
            }

            .leaflet-bar a:first-child:hover,
            .leaflet-bar a:last-child:hover,
            .leaflet-touch .leaflet-bar a:first-child:hover,
            .leaflet-touch .leaflet-bar a:last-child:hover {
                background-color: #676869 !important;
                border-color: #676869 !important;
                color: #fff !important;
            }

            .leaflet-bar a:first-child:active,
            .leaflet-bar a:last-child:active,
            .leaflet-touch .leaflet-bar a:first-child:active,
            .leaflet-touch .leaflet-bar a:last-child:active {
                background-color: #2a2a2a !important;
                border-color: #2a2a2a !important;
                color: #b9dc0c !important;
            }

            .leaflet-bar a:first-child.leaflet-disabled,
            .leaflet-bar a:last-child.leaflet-disabled,
            .leaflet-touch .leaflet-bar a:first-child.leaflet-disabled,
            .leaflet-touch .leaflet-bar a:last-child.leaflet-disabled {
                background-color: #2a2a2a !important;
                border-color: #2a2a2a !important;
                color: #969696 !important;
            }

            /* Layer Control Styling */

            .leaflet-control-layers {
                border-radius: 0;
                background-color: #2a2a2a !important;
                border-color: #2a2a2a !important;
                color: #fff !important;
            }

            /* Leaflet Popup */

            .leaflet-popup-content-wrapper {
                background: #2a2a2a;
                border-radius: 0;
                color: #fff;
                font-size: 1.2em;
                padding: 2px;
                white-space: nowrap;
            }

            .leaflet-popup-tip {
                background: #2a2a2a;
            }

        </style>

</head>

<body>

    <h3 id="mapTitle" class="mapTitle"></h3>

    <div id="map"></div>

    <script>

        var map,
            meteomaticsProxy = "https://betatest.metoffice.gov.uk/enthusiast/api/proxy",
            layer = "300hPa",
            params = {
                resolution: 0.5,
                maxLat: 80,
                minLat: -80,
                minLon: -180,
                maxLon: 180
            },
            uWindParams = "/todayT12Z/wind_speed_u_" + layer + ":ms/" + params.maxLat + "," + params.minLon + "_" + params.minLat + "," + params.maxLon + ":" + params.resolution + "," + params.resolution + "/json?model=ncep-gfs",
            vWindParams = "/todayT12Z/wind_speed_v_" + layer + ":ms/" + params.maxLat + "," + params.minLon + "_" + params.minLat + "," + params.maxLon + ":" + params.resolution + "," + params.resolution + "/json?model=ncep-gfs",
            uWind,
            vWind,
            vectorField,
            bounds;

        // Set document title
        document.title = layer + " forecast winds for midday today";

        // Set page header
        document.getElementById("mapTitle").innerHTML = layer + " forecast winds for midday today";

        // Create the bare map
        map = createMap();

        // Get U Wind
        uWind = getWindVectorData(meteomaticsProxy, uWindParams);

        // Get V Wind
        vWind = getWindVectorData(meteomaticsProxy, vWindParams);

        // Sort U Wind
        uWind = sortDataNS(uWind);

        // Sort V Wind
        vWind = sortDataNS(vWind);

        // ASCIIGrid U Wind
        uWind = asciiGridWind(uWind, params);

        // ASCIIGrid V Wind
        vWind = asciiGridWind(vWind, params);

        // Display the vector animation
        vectorField = displayAnimation(map);

        if (vectorField) {

            // Update bounds
            updateBounds(map, vectorField);

        }

        // Recreate animation when move end
        map.on("moveend", function (e) {

            if (vectorField) {

                // Update bounds
                updateBounds(map, vectorField);

            }

        });

        // ##########################################################################################################

        function createMap () {

            var baseLayer,
                dataLayer,
                mapCenter,
                _map

            // Base map layer
            baseLayer = new L.tileLayer('http://donotbeonfire.co.uk:8080/styles/ultra-dark-theme/{z}/{x}/{y}{r}.png');

            mapCenter = new L.LatLng(20, -25);

            _map = new L.Map("map", {

                // Config
                center: mapCenter,
                zoom: 3,
                maxZoom: 5,
                crs: L.CRS.EPSG3857,
                layers: [baseLayer],
                attributionControl: false,
                zoomControl: false

            });

            L.control.zoom({

                position: 'bottomright'

            }).addTo(_map);

            _map.setMaxBounds([
                [90, -180],
                [-90, 180]
            ]);

            _map.setMinZoom(2);

            _map.invalidateSize();

            return _map;

        }

        function getWindVectorData (url, parameters) {

            // Get Wind Vector Data
            var xhr = new XMLHttpRequest(),
                JSONString;

            // Get data from API via proxy
            xhr.open("GET", url + parameters, false);
            xhr.onload = function() {
                if (xhr.status !== 200) {
                    alert(xhr.responseText);
                } else {
                    JSONString = JSON.parse(xhr.responseText);
                }
            };
            xhr.send("");

            return JSONString;

        }

        function sortDataNS (JSONString) {

            var JSONString;

            JSONString.data[0].coordinates = JSONString.data[0].coordinates.sort(function (a, b) {
                return b.lat - a.lat;
            });

            return JSONString;

        }

        function asciiGridWind (JSONString) {

            var asciiString = "",
                headerString = "",
                dataString = "",
                rowCounter,
                rowString = "";

            // Header
            headerString = headerString + "ncols  " + (((params.maxLon - params.minLon) / params.resolution) + 1) + "\n";
            headerString = headerString + "nrows  " + (((params.maxLat - params.minLat) / params.resolution) + 1) + "\n";
            headerString = headerString + "xllcorner  " + (params.minLon - (params.resolution / 2)) + "\n";
            headerString = headerString + "yllcorner  " + (params.minLat - (params.resolution / 2)) + "\n";
            headerString = headerString + "cellsize  " + params.resolution + "\n";
            headerString = headerString + "NODATA_value  -999\n";

            // Data
            JSONString.data[0].coordinates.forEach(function(element) {

                if (!rowCounter) {
                    rowCounter = element.lat;
                }

                if (element.lat === rowCounter) {

                    // Add next value
                    rowString = rowString + element.dates[0].value + " ";

                } else {

                    // Complete row
                    rowString = rowString + "\n";
                    dataString = dataString + rowString;

                    // Start new row
                    rowString = "";
                    rowCounter = element.lat;
                    rowString = rowString + element.dates[0].value + " ";

                }

            });

            // Finalise parts
            ASCIIString = headerString + dataString + "\n";

            return ASCIIString;

        }

        function displayAnimation (surface) {

            // ScalarField derived from a Vectorfield
            const toMetersPerSecond = 1;
            var vf = L.VectorField.fromASCIIGrids(uWind, vWind, toMetersPerSecond);

            var scaleVIRIDIS = chroma.scale(['#440154', '#482777', '#3F4A8A', '#31678E', '#26838F', '#1F9D8A', '#6CCE5A', '#B6DE2B', '#FEE825']).domain(vf.range);

            // Magnitude Layer
            const s = vf.getScalarField('magnitude'); // << derived ScalarField
            const magnitude = L.canvasLayer.scalarField(s, {
                interpolate: true,
                color: scaleVIRIDIS,
                opacity: 0.6
            });

            // Direction layer
            const direction = L.canvasLayer.scalarField (
                vf.getScalarField('directionFrom'), {
                    type: 'vector',
                    color: '#aaa',
                    vectorSize: 20,
                    arrowDirection: 'from'
                }
            );

            // Animation layer
            const animation = L.canvasLayer.vectorFieldAnim(vf, {
                paths: 4000,
                fade: 0.98,
                maxAge: 100,
                velocityScale: 0.02,
                color: scaleVIRIDIS,
                width: 1.2,
                opacity: 0.9
            }).addTo(surface);

            L.control.layers(
                {},
                {
                    "Vector animation": animation,
                    "Derived magnitude": magnitude,
                    "Derived direction": direction,
                }, {
                    position: 'bottomleft',
                    collapsed: false
                }
            ).addTo(surface);

            // Simple colorbar
            var bar = L.control.colorBar(scaleVIRIDIS, vf.range, {
                title: 'Wind velocity (m/s)',
                units: 'm/s',
                steps: 100,
                decimals: 0,
                width: 270,
                height: 20,
                position: 'topright',
                background: '#2a2a2a',
                textColor: 'white',
                labels: [0, 25, 50, 75, 100],
                textLabels: [],
                labelTextPosition: 'end'
            }).addTo(map);

            magnitude.on('click', function (e) {
                if (e.value !== null) {
                    var v = (e.value).toFixed(1);
                    var html = 'Wind speed: ' + v + ' m/s';
                    var popup = L.popup().setLatLng(e.latlng).setContent(html).openOn(map);
                }
            });

            direction.on('click', function (e) {
                if (e.value !== null) {
                    let v = e.value.toFixed(0);
                    let html = 'Wind direction: ' + v + ' degrees';
                    let popup = L.popup().setLatLng(e.latlng).setContent(html).openOn(map);
                }
            });

            return vf

        }

        function updateBounds(map, vectorField) {

            bounds = map.getBounds();

            // Add padding
            bounds._southWest.lat = bounds._southWest.lat - 2;
            bounds._southWest.lng = bounds._southWest.lng - 2;
            bounds._northEast.lat = bounds._northEast.lat + 2;
            bounds._northEast.lng = bounds._northEast.lng + 2;

            // Clamp bounds
            if (bounds._southWest.lat < -80) {
                bounds._southWest.lat = -80
            }

            if (bounds._southWest.lng < -180) {
                bounds._southWest.lng = -180
            }

            if (bounds._northEast.lat > 80) {
                bounds._northEast.lat = 80
            }

            if (bounds._northEast.lng > 180) {
                bounds._northEast.lng = 180
            }

            const mask = {
                "type": "Feature",
                "properties": {},
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [
                        [
                            [
                                bounds._southWest.lng,
                                bounds._northEast.lat
                            ],
                            [
                                bounds._southWest.lng,
                                bounds._southWest.lat
                            ],
                            [
                                bounds._northEast.lng,
                                bounds._southWest.lat
                            ],
                            [
                                bounds._northEast.lng,
                                bounds._northEast.lat
                            ],
                            [
                                bounds._southWest.lng,
                                bounds._northEast.lat
                            ]
                        ]
                    ]
                }
            };

            vectorField.setSpatialMask(mask);

        }

    </script>

</body>

</html>